Chapter1 - 2. 현행 시스템 분석
==============================

## (1) 현행 시스템 파악
- 구성/기능/인터페이스 -> 아키텍처/소프트웨어 -> 하드웨어/네트워크 구성 파악
<br>

### 1-1. 소프트웨어 아키텍처
- 소프트웨어 아키텍처 4+1뷰
  - 고객의 요구사항 4가지 관점에서 검토
  - 4(논리, 프로세스, 구현, 배포) + 1(유스케이스)
    - 유스케이스 뷰: 도출, 설계, 다른 뷰 검증
    - 논리 뷰: 기능적 요구사항
    - 프로세스 뷰: 비기능적 요구사항
    - 구현 뷰: 정적 부분, 컴포넌트 구조와 의존성
    - 배포 뷰: 물리적 아키텍처에 배치 시연
<br>

- 소프트웨어 아키텍처 패턴
  - 계층화 패턴: 하위 모듈이 추상화 제공, 서로 마주보는 두 계층 사이에서만 상호작용
  - 클라이언트 - 서버 패턴
  - 파이프 - 필터 패턴: 데이터 스트림 생성 및 처리 시스템에서 사용, 재사용성과 확장 용이
  - 브로커 패턴: 분산 시스템에서 사용
  - MVC 패턴
    - 모델: 핵심 기능과 데이터 보관
    - 뷰: 사용자에게 정보 표시
    - 컨트롤러: 사용자로부터 요청 입력받아 처리
<br>

- 소프트웨어 아키텍처 비용 평가 모델 종류
  - SAAM: 변경 용이성과 기능성에 집중, 경험이 없는 조직에서도 활용가능
  - ATAM: 아키텍처 품질 속성이 기준
  - CBAM: 경제적 의사결정에 대한 요구가 기준
  - ADR: 아키텍처 구성요소간 응집도 평가
  - ARID: 특정 품질요소 평가에 집중
<br>

### 1-2. 디자인 패턴
- 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴
<br>

- 디자인 패턴 유형(많아서 헷갈림)
  - 생성패턴
    - Builder: 복잡한 인스턴스를 조립, 객체 생성과 구현 방법 분리
    - Prototype: 원형 제작 후 복사본을 수정하여 사용
    - Factory Method: 상위 클래스 - 인터페이스, 하위 클래스 - 인스턴스 생성
    - Abstract Factory: 인터페이스 제공, 구체적인 구현은 Concrete Product 클래스에서 이루어짐
    - Singleton: 전역변수 X, 한 클래스에 한 객체만
  <br>
  
  - 구조패턴
    - Bridge: 기능의 클래스 - 구현 연결, 추상계층 / 실제구현 독립적 확장 가능
    - Decorator: 객체 간의 결합을 통해 기능 확장
    - Facade: 복잡한 시스템에 대해 단순한 인터페이스 제공
    - Flyweight: 여러 개의 가상 인스턴스를 제공하여 메모리 절감
    - Proxy: 대리객체, 메모리 절감 및 정보은닉
    - Composite: 객체를 트리(부분 - 전체) 계층으로, 복합 객체와 단일 객체를 동일하게 취급
    - Adapter: 
    - Mediator: 객체 수 증가로 인한 결합도 증가 방지를 위한 중재자 설정
    - Interpreter: 구문 분리 및 해석, 문법 자체를 캡슐화
<br>

  - 행위패턴
    - Iterator: 내부 구조 노출X, 객체 원소 순차적 접근 가능
    - Template Method: 상위 작업의 구조를 바꾸지 않으면서 서브 클래스로 작업의 일부분을 수행, 변경
    - Observer: 객체의 상태 변화에 따라 다른 객체의 상태도 연동
    - State: 객체 상태를 캡슐화(클래스화), 객체의 상태에 따라 행위 내용 변경
    - Visitor: 클래스로부터 메서드를 별도의 클래스로 분리 및 독립적 행동, 기능만 따로 추가하거나 확장 가능
    - Command: 기능(요구사항)을 캡슐화
    - Strategy: 같은 알고리즘을 클래스로 캡슐화, 필요할 때 서로 교환
    - Memento: 객체 정보를 저장할 필요가 있을 때 적용, Undo 기능으로 객체를 이전 상태로 복구 가능
    -행




